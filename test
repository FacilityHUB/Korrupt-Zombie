local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager =
	loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(
	game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua")
)()

local Window = Fluent:CreateWindow({
	Title = "Facility v2.0.0.0b",
	SubTitle = "by Individu",
	TabWidth = 160,
	Size = UDim2.fromOffset(580, 460),
	Acrylic = false,
	Theme = "Darker",
	MinimizeKey = Enum.KeyCode.LeftControl,
})

local Tabs = {
	Main = Window:AddTab({ Title = "Main", Icon = "" }),
	Aimbot = Window:AddTab({ Title = "Aimbot", Icon = "" }),
	Crooshair = Window:AddTab({ Title = "CrossHair", Icon = "" }),
	Esp = Window:AddTab({ Title = "Visual", Icon = "" }),
	Misc = Window:AddTab({ Title = "Misc", Icon = "" }),
	Settings = Window:AddTab({ Title = "Settings", Icon = "settings" }),
}

local Options = Fluent.Options

--//Main\\--

--//WalkSpeed\\--
local Players = game:GetService("Players")
local player = Players.LocalPlayer

local defaultWalkSpeed = 16
local targetWalkSpeed = 80
local isWalkSpeedEnabled = false

local Toggle = Tabs.Main:AddToggle("WalkSpeed", { Title = "WalkSpeed", Default = false })

Toggle:OnChanged(function(value)
	isWalkSpeedEnabled = value
	if player and player.Character then
		local humanoid = player.Character:WaitForChild("Humanoid")
		humanoid.WalkSpeed = isWalkSpeedEnabled and targetWalkSpeed or defaultWalkSpeed
	end
end)

local function onCharacterAdded(character)
	local humanoid = character:WaitForChild("Humanoid")
	humanoid.WalkSpeed = isWalkSpeedEnabled and targetWalkSpeed or defaultWalkSpeed

	humanoid:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
		if isWalkSpeedEnabled and humanoid.WalkSpeed ~= targetWalkSpeed then
			humanoid.WalkSpeed = targetWalkSpeed
		end
	end)
end

player.CharacterAdded:Connect(onCharacterAdded)

if player.Character then
	onCharacterAdded(player.Character)
end

--//Slider WalkSpeed\\--
local Slider = Tabs.Main:AddSlider("Slider", {
	Title = "Slider WalkSpeed",
	Description = "",
	Default = targetWalkSpeed,
	Min = 16,
	Max = 150,
	Rounding = 1,
	Callback = function(Value)
		targetWalkSpeed = Value
		if isWalkSpeedEnabled and player.Character then
			local humanoid = player.Character:FindFirstChild("Humanoid")
			if humanoid then
				humanoid.WalkSpeed = targetWalkSpeed
			end
		end
	end,
})

Slider:SetValue(targetWalkSpeed)

Slider:OnChanged(function(Value)
	if not isWalkSpeedEnabled then
	else
	end
end)

--//JumpPower\\--
local Players = game:GetService("Players")
local player = Players.LocalPlayer

local defaultJumpPower = 16
local targetJumpPower = 60
local isJumpEnabled = false

local Toggle = Tabs.Main:AddToggle("JumpPower", { Title = "JumpPower", Default = false })

Toggle:OnChanged(function(value)
	isJumpEnabled = value
	if player and player.Character then
		local humanoid = player.Character:WaitForChild("Humanoid")
		humanoid.JumpPower = isJumpEnabled and targetJumpPower or defaultJumpPower
	end
end)

local function onCharacterAdded(character)
	local humanoid = character:WaitForChild("Humanoid")
	humanoid.JumpPower = isJumpEnabled and targetJumpPower or defaultJumpPower

	humanoid:GetPropertyChangedSignal("JumpPower"):Connect(function()
		if isJumpEnabled and humanoid.JumpPower ~= targetJumpPower then
			humanoid.JumpPower = targetJumpPower
		end
	end)
end

player.CharacterAdded:Connect(onCharacterAdded)

if player.Character then
	onCharacterAdded(player.Character)
end

--//Slider for JumpPower\\--

local JumpPowerSlider = Tabs.Main:AddSlider("JumpPowerSlider", {
	Title = "Slider JumpPower",
	Default = targetJumpPower,
	Min = 16,
	Max = 200,
	Rounding = 1,
	Callback = function(Value)
		targetJumpPower = Value
		if isJumpEnabled and player.Character then
			local humanoid = player.Character:FindFirstChild("Humanoid")
			if humanoid then
				humanoid.JumpPower = targetJumpPower
			end
		end
	end,
})

JumpPowerSlider:SetValue(targetJumpPower)

JumpPowerSlider:OnChanged(function(Value)
	if not isJumpEnabled then
	else
	end
end)

--//Noclip\\--

local Toggle = Tabs.Main:AddToggle("Noclip", { Title = "Noclip", Default = false })

Toggle:OnChanged(function()
	_G.NoIndividu = Toggle.Value

	local RunService = game:GetService("RunService")
	local speaker = (game:FindFirstChild("Players - Client") or game.Players).LocalPlayer
	local initialCollisions = {}

	local function SaveInitialCollisions()
		if speaker.Character then
			for _, child in pairs(speaker.Character:GetDescendants()) do
				if child:IsA("BasePart") then
					initialCollisions[child] = child.CanCollide
				end
			end
		end
	end

	local function NoclipLoop()
		if _G.NoIndividu and speaker.Character then
			for _, child in pairs(speaker.Character:GetDescendants()) do
				if child:IsA("BasePart") then
					child.CanCollide = false
				end
			end
		else
			for part, initialCanCollide in pairs(initialCollisions) do
				if part and part:IsA("BasePart") then
					part.CanCollide = initialCanCollide
				end
			end
			initialCollisions = {}
		end
	end

	local function UpdateNoclip()
		if _G.NoIndividu then
			SaveInitialCollisions()
			RunService.Stepped:Connect(NoclipLoop)
		else
			NoclipLoop()
		end
	end

	UpdateNoclip()

	_G.NoIndividuChanged = function(newValue)
		_G.NoIndividu = newValue
		UpdateNoclip()
	end
end)

Options.Noclip:SetValue(false)

--//MultiJump\\--

local InfiniteJumpEnabled = false

local Toggle = Tabs.Main:AddToggle("MultiJumpToggle", {
	Title = "MultiJump",
	Default = false,
})

Toggle:OnChanged(function(value)
	InfiniteJumpEnabled = value
	if InfiniteJumpEnabled then
		game:GetService("UserInputService").JumpRequest:Connect(function()
			if InfiniteJumpEnabled then
				game:GetService("Players").LocalPlayer.Character
					:FindFirstChildOfClass("Humanoid")
					:ChangeState("Jumping")
			end
		end)
	end
end)

--//Fly\\--

local flying = false
local speed = 0
local maxspeed = 100
local ctrl = { f = 0, b = 0, l = 0, r = 0 }
local lastctrl = { f = 0, b = 0, l = 0, r = 0 }

local Slider = Tabs.Main:AddSlider("Slider", {
	Title = "Speed Fly",
	Description = "Adjust the fly speed",
	Default = maxspeed,
	Min = 0,
	Max = 1000,
	Rounding = 1,
	Callback = function(Value)
		maxspeed = Value
		if flying then
			speed = maxspeed
		end
	end,
})

Slider:OnChanged(function(Value)
	maxspeed = Value
	if flying then
		speed = maxspeed
	end
end)

local plr = (game:FindFirstChild("Players - Client") or game.Players).LocalPlayer
local mouse = plr:GetMouse()
local torso = plr.Character and plr.Character:FindFirstChild("HumanoidRootPart")

function StartFlying()
	local bg = Instance.new("BodyGyro", torso)
	bg.P = 9e4
	bg.maxTorque = Vector3.new(9e9, 9e9, 9e9)
	bg.cframe = torso.CFrame
	local bv = Instance.new("BodyVelocity", torso)
	bv.velocity = Vector3.new(0, 0, 0)
	bv.maxForce = Vector3.new(9e9, 9e9, 9e9)

	speed = maxspeed

	repeat
		wait()
		plr.Character.Humanoid.PlatformStand = true

		local moveVector = (
			(game:FindFirstChild("Workspace - Client") or game.Workspace).CurrentCamera.CFrame.lookVector
			* (ctrl.f + ctrl.b)
		)
			+ (
				(
					(game:FindFirstChild("Workspace - Client") or game.Workspace).CurrentCamera.CFrame
					* CFrame.new(ctrl.l + ctrl.r, (ctrl.f + ctrl.b) * 0.2, 0).p
				) - (game:FindFirstChild("Workspace - Client") or game.Workspace).CurrentCamera.CFrame.p
			)

		bv.velocity = moveVector * speed

		bg.cframe = (game:FindFirstChild("Workspace - Client") or game.Workspace).CurrentCamera.CFrame
			* CFrame.Angles(-math.rad((ctrl.f + ctrl.b) * 50 * speed / maxspeed), 0, 0)
	until not flying

	bg:Destroy()
	bv:Destroy()
	plr.Character.Humanoid.PlatformStand = false
end

if torso then
	plr.Character.Humanoid.StateChanged:Connect(function(_, newState)
		if newState == Enum.HumanoidStateType.Running then
			ctrl.f = 1
		else
			ctrl.f = 0
		end
	end)
end

mouse.KeyDown:Connect(function(key)
	if key:lower() == "w" then
		ctrl.f = 1
	elseif key:lower() == "s" then
		ctrl.b = -1
	elseif key:lower() == "a" then
		ctrl.l = -1
	elseif key:lower() == "d" then
		ctrl.r = 1
	end
end)

mouse.KeyUp:Connect(function(key)
	if key:lower() == "w" then
		ctrl.f = 0
	elseif key:lower() == "s" then
		ctrl.b = 0
	elseif key:lower() == "a" then
		ctrl.l = 0
	elseif key:lower() == "d" then
		ctrl.r = 0
	end
end)

plr.CharacterAdded:Connect(function(character)
	torso = character:WaitForChild("HumanoidRootPart")
	if flying then
		StartFlying()
	end
	plr.Character.Humanoid.StateChanged:Connect(function(_, newState)
		if newState == Enum.HumanoidStateType.Running then
			ctrl.f = 1
		else
			ctrl.f = 0
		end
	end)
end)

plr.CharacterRemoving:Connect(function()
	flying = false
end)

function ToggleFlying()
	flying = not flying
	if flying then
		if torso then
			StartFlying()
		end
	end
end

local Keybind = Tabs.Main:AddKeybind("Keybind", {
	Title = "Fly",
	Mode = "Toggle",
	Default = "Q",
	Callback = function(Value)
		ToggleFlying()
	end,
})

--//AimBot\\--
_G.AimBot_Checks = {
	TeamCheck = true,
	WallCheck = true,
	AliveCheck = true,
}

_G.AimBot_Fov = {
	Enable = true,
	Visible = false,
	Thickness = 0.6,
	Color = Color3.fromRGB(255, 255, 255),
	LockColor = Color3.fromRGB(255, 0, 0),
	OffColor = Color3.fromRGB(150, 150, 150),
	Filled = false,
	Size = 160,
}

_G.selectedPart = "Head"

local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local Cam = game.Workspace.CurrentCamera
local Mouse = Players.LocalPlayer:GetMouse()

local maxDistance = 500
local sensitivity = 0.1

local aimbotActive = false
local rightClickHeld = false

local function moveMouseToTarget(targetPosition)
	local targetPos = Cam:WorldToViewportPoint(targetPosition)
	local viewportCenter = Vector2.new(Cam.ViewportSize.X / 2, Cam.ViewportSize.Y / 2)
	local offset = Vector2.new(targetPos.X - viewportCenter.X, targetPos.Y - viewportCenter.Y)
	mousemoverel(offset.X * sensitivity, offset.Y * sensitivity)
end

local function getClosestPlayerToMouse(trg_part)
	local nearest = nil
	local lastDistance = maxDistance
	local mousePosition = Vector2.new(Mouse.X, Mouse.Y)

	for _, player in ipairs(Players:GetPlayers()) do
		if player ~= Players.LocalPlayer then
			local part = player.Character and player.Character:FindFirstChild(trg_part, true)
			local humanoid = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
			if part and humanoid and humanoid.Health > 0 then
				if _G.AimBot_Checks.AliveCheck and humanoid.Health <= 0 then
					continue
				end

				local ray = workspace:FindPartOnRayWithIgnoreList(
					Ray.new(
						Cam.CFrame.Position,
						(part.Position - Cam.CFrame.Position).Unit * (part.Position - Cam.CFrame.Position).Magnitude
					),
					{ Players.LocalPlayer.Character, Cam }
				)
				if _G.AimBot_Checks.WallCheck and (not ray or not ray:IsDescendantOf(player.Character)) then
					continue
				end

				if
					_G.AimBot_Checks.TeamCheck
					and player.Character:FindFirstChild("HumanoidRootPart")
					and player.Character.HumanoidRootPart:FindFirstChild("TeammateLabel")
				then
					continue
				end

				local ePos, isVisible = Cam:WorldToViewportPoint(part.Position)
				local distanceFromMouse = (Vector2.new(ePos.X, ePos.Y) - mousePosition).Magnitude
				local distanceFromPlayer = (Cam.CFrame.Position - part.Position).Magnitude

				if _G.AimBot_Fov.Enable and distanceFromMouse > _G.AimBot_Fov.Size then
					continue
				end

				if isVisible and distanceFromMouse < lastDistance and distanceFromPlayer <= maxDistance then
					nearest, lastDistance = player, distanceFromMouse
				end
			end
		end
	end

	return nearest
end

local FOV = Drawing.new("Circle")
FOV.Visible = _G.AimBot_Fov.Visible
FOV.Thickness = _G.AimBot_Fov.Thickness
FOV.Color = _G.AimBot_Fov.Color
FOV.Filled = _G.AimBot_Fov.Filled
FOV.Radius = _G.AimBot_Fov.Size
FOV.Position = Vector2.new(Cam.ViewportSize.X / 2, Cam.ViewportSize.Y / 2)

RunService.RenderStepped:Connect(function()
	FOV.Position = Vector2.new(Mouse.X, Mouse.Y)

	if aimbotActive and rightClickHeld then
		local closest = getClosestPlayerToMouse(_G.selectedPart)
		if closest and closest.Character:FindFirstChild(_G.selectedPart, true) then
			local targetPart = closest.Character:FindFirstChild(_G.selectedPart, true)
			moveMouseToTarget(targetPart.Position)
		end
	end
end)

UserInputService.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton2 then
		rightClickHeld = true
	end
end)

UserInputService.InputEnded:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton2 then
		rightClickHeld = false
	end
end)

_G.AimBot_Values = {
	Enable = true,
	Toggle = true,
	HitPart = _G.selectedPart,
	HitPartList = {
		_G.selectedPart,
		"LeftFoot",
	},
	TriggerKeyEnabled = true,
}

local VirtualInputManager = game:GetService("VirtualInputManager")
local runS = game:GetService("RunService")
local pl = game:GetService("Players")
local lp = pl.LocalPlayer
local char = lp.Character or lp.CharacterAdded:Wait()
local ws = game:GetService("Workspace")
local camera = workspace.CurrentCamera
local UIS = game:GetService("UserInputService")
local mousePPos = UIS:GetMouseLocation()
runS.RenderStepped:Connect(function()
	mousePPos = UIS:GetMouseLocation()
end)
local Center = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)

do -- Aimbot
	coroutine.wrap(function()
		local lock = false

		local function GetPartToFov(Part)
			for _, v in ipairs(pl:GetPlayers()) do
				if v ~= lp and v.Character and v.Character:FindFirstChild(Part) then
					if
						_G.AimBot_Checks.AliveCheck
						and v.Character:FindFirstChildOfClass("Humanoid")
						and v.Character.Humanoid.Health <= 0
					then
						continue
					end

					local ray = workspace:FindPartOnRayWithIgnoreList(
						Ray.new(
							camera.CFrame.Position,
							(v.Character[Part].Position - camera.CFrame.Position).Unit
								* (v.Character[Part].Position - camera.CFrame.Position).Magnitude
						),
						{ lp.Character, camera }
					)

					if _G.AimBot_Checks.WallCheck and (not ray or not ray:IsDescendantOf(v.Character)) then
						continue
					end
					if
						_G.AimBot_Checks.TeamCheck
						and v.Character:FindFirstChild("HumanoidRootPart")
						and v.Character.HumanoidRootPart:FindFirstChild("TeammateLabel")
					then
						continue
					end
					local vPos = camera:WorldToViewportPoint(v.Character[Part].Position)
					local distance = (Vector2.new(vPos.X, vPos.Y) - mousePPos).Magnitude

					if _G.AimBot_Fov.Enable and (distance > _G.AimBot_Fov.Size) then
						continue
					end
					return v
				end
			end
		end

		UIS.InputBegan:Connect(function(input, gameProcessedEvent)
			if gameProcessedEvent then
				return
			end
			if _G.AimBot_Values.TriggerKeyEnabled then
				lock = true
			else
				lock = false
			end
		end)

		while task.wait() do
			if _G.AimBot_Values.Enable then
				if not lp.PlayerGui.MainGui.MainFrame.Lobby.Currency.Visible then
					local Target = nil
					Target = GetPartToFov(_G.AimBot_Values.HitPart)

					if Target ~= nil then
					end

					if
						(_G.AimBot_Values.Toggle == true and lock == false)
						or (
							_G.AimBot_Values.Toggle == false
							and not UIS:IsMouseButtonPressed(Enum.UserInputType.MouseButton2)
						)
					then
					end

					if
						Target
						and Target.Character
						and Target.Character:FindFirstChild(_G.AimBot_Values.HitPart)
						and lock
						and camera:WorldToViewportPoint(Target.Character[_G.AimBot_Values.HitPart].Position).Z > 0
					then
						if not _G.AimBot_Values.Toggle and not _G.AimBot_Values.TriggerKeyEnabled then
							continue
						end

						camera.CFrame = CFrame.new(
							camera.CFrame.Position
								+ (Target.Character[_G.AimBot_Values.HitPart].Position - camera.CFrame.Position).Unit
									* 0.5,
							Target.Character[_G.AimBot_Values.HitPart].Position
						)
					end
				end
			end
		end
	end)()
end

--Aimbot Enabled
local Toggle = Tabs.Aimbot:AddToggle("AimbotMouse", { Title = "Aimbot", Default = false })

Toggle:OnChanged(function()
	aimbotActive = Toggle.Value
end)

--//SilentAim\\--

local Toggle = Tabs.Aimbot:AddToggle("Silent", { Title = "Silent Aim (Spam Click)", Default = false })

Toggle:OnChanged(function()
	_G.AimBot_Values.TriggerKeyEnabled = Toggle.Value
end)

_G.AimBot_Values.TriggerKeyEnabled = Toggle.Value

--Aimbot Sensi
local SensitivitySlider = Tabs.Aimbot:AddSlider("SensitivitySlider", {
	Title = "Aimbot Sensitivity",
	Description = "",
	Default = sensitivity,
	Min = 0.1,
	Max = 1,
	Rounding = 1,
	Callback = function(Value)
		sensitivity = Value
	end,
})

SensitivitySlider:SetValue(sensitivity)

--Aim Part
local PartDropdown = Tabs.Aimbot:AddDropdown("PartDropdown", {
	Title = "Aim Part",
	Values = { "Head", "UpperTorso", "LowerTorso" },
	Multi = false,
	Default = "Head",
})

PartDropdown:SetValue("Head")

PartDropdown:OnChanged(function(Value)
	_G.selectedPart = Value
end)

local InterfaceSection = Tabs.Aimbot:AddSection("Checks")

--TeamChecks
local TeamCheckToggle =
	Tabs.Aimbot:AddToggle("TeamCheckToggle", { Title = "Team Check", Default = _G.AimBot_Checks.TeamCheck })
TeamCheckToggle:OnChanged(function()
	_G.AimBot_Checks.TeamCheck = TeamCheckToggle.Value
end)
Options.TeamCheckToggle:SetValue(_G.AimBot_Checks.TeamCheck)

--WallCheck
local WallCheckToggle =
	Tabs.Aimbot:AddToggle("WallCheckToggle", { Title = "Wall Check", Default = _G.AimBot_Checks.WallCheck })
WallCheckToggle:OnChanged(function()
	_G.AimBot_Checks.WallCheck = WallCheckToggle.Value
end)
Options.WallCheckToggle:SetValue(_G.AimBot_Checks.WallCheck)

--Team Checks
local AliveCheckToggle =
	Tabs.Aimbot:AddToggle("AliveCheckToggle", { Title = "Alive Check", Default = _G.AimBot_Checks.AliveCheck })
AliveCheckToggle:OnChanged(function()
	_G.AimBot_Checks.AliveCheck = AliveCheckToggle.Value
end)
Options.AliveCheckToggle:SetValue(_G.AimBot_Checks.AliveCheck)

local InterfaceSection = Tabs.Aimbot:AddSection("Fov Settings")

--Fov Visible
local FovToggle = Tabs.Aimbot:AddToggle("FovToggle", { Title = "FOV Visible", Default = _G.AimBot_Fov.Visible })

FovToggle:OnChanged(function()
	_G.AimBot_Fov.Visible = FovToggle.Value
	FOV.Visible = FovToggle.Value
end)

Options.FovToggle:SetValue(_G.AimBot_Fov.Visible)

--Fov Size
local SizeSlider = Tabs.Aimbot:AddSlider("SizeSlider", {
	Title = "FOV Size",
	Description = "",
	Default = _G.AimBot_Fov.Size,
	Min = 50,
	Max = 600,
	Rounding = 1,
	Callback = function(Value)
		local numericValue = tonumber(Value)
		if numericValue then
			_G.AimBot_Fov.Size = numericValue
			FOV.Radius = numericValue
		else
			warn("Valeur du slider non valide pour la taille du FOV.")
		end
	end,
})

SizeSlider:SetValue(_G.AimBot_Fov.Size)
SizeSlider:OnChanged(function(Value) end)

--Fov Filled
local FilledToggle = Tabs.Aimbot:AddToggle("FilledToggle", { Title = "FOV Filled", Default = _G.AimBot_Fov.Filled })

FilledToggle:OnChanged(function()
	_G.AimBot_Fov.Filled = FilledToggle.Value
	FOV.Filled = FilledToggle.Value
end)

Options.FilledToggle:SetValue(_G.AimBot_Fov.Filled)

--Fov Thickness
local ThicknessSlider = Tabs.Aimbot:AddSlider("ThicknessSlider", {
	Title = "FOV Thickness",
	Description = "",
	Default = _G.AimBot_Fov.Thickness,
	Min = 0.6,
	Max = 50,
	Rounding = 1,
	Callback = function(Value)
		_G.AimBot_Fov.Thickness = Value
		FOV.Thickness = Value
	end,
})

ThicknessSlider:SetValue(_G.AimBot_Fov.Thickness)

--Fov Color
local Colorpicker = Tabs.Aimbot:AddColorpicker("Colorpicker", {
	Title = "FOV Color",
	Default = Color3.fromRGB(96, 205, 255),
})

Colorpicker:OnChanged(function()
	FOV.Color = Colorpicker.Value
end)

Colorpicker:SetValueRGB(Color3.fromRGB(0, 255, 140))

--//TriggerBot\\--

--//CrossHair\\--
--[[
local player = game:GetService("Players").LocalPlayer
local mouse = player:GetMouse()
local gui = Instance.new("ScreenGui")
gui.Parent = game:GetService("CoreGui")

local enableCrosshair = false
local enablePulse = false
local enableRotation = false
local angle = 0
local baseRadius = 20
local pulseAmplitude = 5
local pulseSpeed = 2
local rotationSpeed = 100
local crosshairColor = Color3.fromRGB(255, 255, 255)

local function createLine(size, position)
	local line = Instance.new("Frame")
	line.Size = size
	line.Position = position
	line.BackgroundColor3 = crosshairColor
	line.BorderSizePixel = 0
	line.AnchorPoint = Vector2.new(0.5, 0.5)
	line.Parent = gui
	return line
end

local lineTop = createLine(UDim2.new(0, 10, 0, 2), UDim2.new(0.5, 0, 0.5, -7.5))
local lineBottom = createLine(UDim2.new(0, 10, 0, 2), UDim2.new(0.5, 0, 0.5, 7.5))
local lineLeft = createLine(UDim2.new(0, 2, 0, 10), UDim2.new(0.5, -7.5, 0.5, 0))
local lineRight = createLine(UDim2.new(0, 2, 0, 10), UDim2.new(0.5, 7.5, 0.5, 0))

local function updateCrosshairVisibility()
	for _, line in pairs({ lineTop, lineBottom, lineLeft, lineRight }) do
		line.Visible = enableCrosshair
	end
end

local function createCrosshair()
	lineTop = createLine(UDim2.new(0, 10, 0, 2), UDim2.new(0.5, 0, 0.5, -7.5))
	lineBottom = createLine(UDim2.new(0, 10, 0, 2), UDim2.new(0.5, 0, 0.5, 7.5))
	lineLeft = createLine(UDim2.new(0, 2, 0, 10), UDim2.new(0.5, -7.5, 0.5, 0))
	lineRight = createLine(UDim2.new(0, 2, 0, 10), UDim2.new(0.5, 7.5, 0.5, 0))

	updateCrosshairVisibility()
end

createCrosshair()

game:GetService("Players").LocalPlayer.CharacterAdded:Connect(function()
	gui:ClearAllChildren()
	createCrosshair()
end)

local ToggleCrosshair = Tabs.Crooshair:AddToggle("EnableCrosshair", { Title = "Crosshair", Default = enableCrosshair })

ToggleCrosshair:OnChanged(function()
	enableCrosshair = ToggleCrosshair.Value
	updateCrosshairVisibility()
	game:GetService("Players").LocalPlayer.PlayerGui.MainGui.MainFrame.ItemInterfaces.Visible = not enableCrosshair
end)

local TogglePulse = Tabs.Crooshair:AddToggle("EnablePulse", { Title = "Pulse Effect", Default = enablePulse })
TogglePulse:OnChanged(function()
	enablePulse = TogglePulse.Value
end)

local ToggleRotation =
	Tabs.Crooshair:AddToggle("EnableRotation", { Title = "Rotation Effect", Default = enableRotation })
ToggleRotation:OnChanged(function()
	enableRotation = ToggleRotation.Value
end)

local SliderAngle = Tabs.Crooshair:AddSlider("Angle", {
	Title = "Angle",
	Description = "",
	Default = angle,
	Min = 0,
	Max = 360,
	Rounding = 1,
	Callback = function(Value)
		angle = Value
	end,
})

local SliderBaseRadius = Tabs.Crooshair:AddSlider("BaseRadius", {
	Title = "Base Radius",
	Description = "",
	Default = baseRadius,
	Min = 10,
	Max = 50,
	Rounding = 1,
	Callback = function(Value)
		baseRadius = Value
	end,
})

local SliderPulseAmplitude = Tabs.Crooshair:AddSlider("PulseAmplitude", {
	Title = "Pulse Amplitude",
	Description = "",
	Default = pulseAmplitude,
	Min = 0,
	Max = 10,
	Rounding = 1,
	Callback = function(Value)
		pulseAmplitude = Value
	end,
})

local SliderPulseSpeed = Tabs.Crooshair:AddSlider("PulseSpeed", {
	Title = "Pulse Speed",
	Description = "",
	Default = pulseSpeed,
	Min = 0,
	Max = 10,
	Rounding = 1,
	Callback = function(Value)
		pulseSpeed = Value
	end,
})

local SliderRotationSpeed = Tabs.Crooshair:AddSlider("RotationSpeed", {
	Title = "Rotation Speed",
	Description = "",
	Default = rotationSpeed,
	Min = 0,
	Max = 500,
	Rounding = 1,
	Callback = function(Value)
		rotationSpeed = Value
	end,
})

local Colorpicker = Tabs.Crooshair:AddColorpicker("Colorpicker", {
	Title = "Crosshair Color",
	Default = crosshairColor,
})

Colorpicker:OnChanged(function()
	crosshairColor = Colorpicker.Value
	for _, line in pairs({ lineTop, lineBottom, lineLeft, lineRight }) do
		line.BackgroundColor3 = crosshairColor
	end
end)

Colorpicker:SetValueRGB(Color3.fromRGB(96, 205, 255))

updateCrosshairVisibility()

game:GetService("RunService").RenderStepped:Connect(function(deltaTime)
	if not enableCrosshair then
		return
	end

	if enableRotation then
		angle = (angle + rotationSpeed * deltaTime) % 360
	end

	local radius = baseRadius
	if enablePulse then
		radius = baseRadius + math.sin(tick() * pulseSpeed) * pulseAmplitude
	end

	local cursorX, cursorY = mouse.X, mouse.Y
	local centerX, centerY = cursorX, cursorY

	lineTop.Position =
		UDim2.new(0, centerX + radius * math.cos(math.rad(angle)), 0, centerY + radius * math.sin(math.rad(angle)))
	lineBottom.Position = UDim2.new(
		0,
		centerX + radius * math.cos(math.rad(angle + 180)),
		0,
		centerY + radius * math.sin(math.rad(angle + 180))
	)
	lineLeft.Position = UDim2.new(
		0,
		centerX + radius * math.cos(math.rad(angle + 90)),
		0,
		centerY + radius * math.sin(math.rad(angle + 90))
	)
	lineRight.Position = UDim2.new(
		0,
		centerX + radius * math.cos(math.rad(angle - 90)),
		0,
		centerY + radius * math.sin(math.rad(angle - 90))
	)

	if enableRotation then
		for _, line in pairs({ lineTop, lineBottom, lineLeft, lineRight }) do
			line.Rotation = angle
		end
	end
end)
--]]

--//Visual\\--

--//HighLight\\--

----------------------------------------------------------------------------------------------------------
local InterfaceSection = Tabs.Esp:AddSection("Esp | Basic")
----------------------------------------------------------------------------------------------------------

local function API_Check()
	if Drawing == nil then
		return "No"
	else
		return "Yes"
	end
end

local Find_Required = API_Check()

if Find_Required == "No" then
	print("API non disponible, mais le reste du code continue...")
else
	-- Le reste du code qui dépend de l'API
	local Players = game:GetService("Players")
	local RunService = game:GetService("RunService")
	local UserInputService = game:GetService("UserInputService")
	local Camera = workspace.CurrentCamera

	local Typing = false

	_G.DefaultSettings = false
	_G.TeamCheck = false
	_G.ESPVisible = false -- Initialiser la visibilité de l'ESP à false
	_G.DisplayOptions = { ["Name"] = false, ["Distance"] = false, ["Health"] = false }
	_G.TextColor = Color3.fromRGB(255, 80, 10)
	_G.TextSize = 14
	_G.Center = true
	_G.Outline = true
	_G.OutlineColor = Color3.fromRGB(0, 0, 0)
	_G.TextTransparency = 0.7
	_G.TextFont = Drawing.Fonts.UI

	local MultiDropdown = Tabs.Esp:AddDropdown("MultiDropdown", {
		Title = "Display Options",
		Description = "You can select multiple values.",
		Values = { "Name", "Distance", "Health" },
		Multi = true,
		Default = {
			Name = false,
			Distance = false,
			Health = false,
		}, -- Aucune valeur sélectionnée par défaut
	})

	MultiDropdown:OnChanged(function(Values)
		-- Mettre à jour les options d'affichage en fonction de la sélection
		_G.DisplayOptions = Values
		_G.ESPVisible = next(Values) ~= nil -- Activer l'ESP si au moins une option est sélectionnée
	end)

	local function CreateESP()
		local function UpdateESP(ESP, player)
			RunService.RenderStepped:Connect(function()
				if
					workspace:FindFirstChild(player.Name) and workspace[player.Name]:FindFirstChild("HumanoidRootPart")
				then
					local Vector, OnScreen =
						Camera:WorldToViewportPoint(workspace[player.Name]:WaitForChild("Head", math.huge).Position)

					ESP.Size = _G.TextSize
					ESP.Center = _G.Center
					ESP.Outline = _G.Outline
					ESP.OutlineColor = _G.OutlineColor
					ESP.Color = _G.TextColor
					ESP.Transparency = _G.TextTransparency
					ESP.Font = _G.TextFont

					if OnScreen and _G.ESPVisible then
						local Part1 = workspace
							:WaitForChild(player.Name, math.huge)
							:WaitForChild("HumanoidRootPart", math.huge).Position
						local Part2 = workspace
							:WaitForChild(Players.LocalPlayer.Name, math.huge)
							:WaitForChild("HumanoidRootPart", math.huge).Position or Vector3.new()
						local Dist = (Part1 - Part2).Magnitude
						local healthText = _G.DisplayOptions["Health"]
								and " [" .. workspace[player.Name].Humanoid.Health .. "]"
							or ""
						local nameText = _G.DisplayOptions["Name"] and player.Name or ""
						local distanceText = _G.DisplayOptions["Distance"] and " (" .. tostring(math.floor(Dist)) .. ")"
							or ""

						ESP.Position = Vector2.new(Vector.X, Vector.Y - 25)
						ESP.Text = nameText .. distanceText .. healthText

						ESP.Visible = _G.ESPVisible
					else
						ESP.Visible = false
					end
				else
					ESP.Visible = false
				end
			end)
		end

		for _, player in next, Players:GetPlayers() do
			if player.Name ~= Players.LocalPlayer.Name then
				local ESP = Drawing.new("Text")
				UpdateESP(ESP, player)
				Players.PlayerRemoving:Connect(function(removingPlayer)
					if removingPlayer == player then
						ESP.Visible = false
					end
				end)
			end
		end

		Players.PlayerAdded:Connect(function(player)
			player.CharacterAdded:Connect(function()
				if player.Name ~= Players.LocalPlayer.Name then
					local ESP = Drawing.new("Text")
					UpdateESP(ESP, player)
					Players.PlayerRemoving:Connect(function(removingPlayer)
						if removingPlayer == player then
							ESP.Visible = false
						end
					end)
				end
			end)
		end)
	end

	if _G.DefaultSettings then
		_G.TeamCheck = false
		_G.ESPVisible = false -- S'assurer que l'ESP est désactivé par défaut
		_G.DisplayOptions = { ["Name"] = false, ["Distance"] = false, ["Health"] = false }
		_G.TextColor = Color3.fromRGB(40, 90, 255)
		_G.TextSize = 14
		_G.Center = true
		_G.Outline = false
		_G.OutlineColor = Color3.fromRGB(0, 0, 0)
		_G.TextTransparency = 0.75
	end

	UserInputService.TextBoxFocused:Connect(function()
		Typing = true
	end)

	UserInputService.TextBoxFocusReleased:Connect(function()
		Typing = false
	end)

	pcall(function()
		CreateESP()
	end)
end

--------------------------------------------------------------------------------------------------------------------
local InterfaceSection = Tabs.Esp:AddSection("Esp | Advanced")
--------------------------------------------------------------------------------------------------------------------

--//HighLight\\--

local Players = game:GetService("Players")

local Toggle = Tabs.Esp:AddToggle("EspHigLight", { Title = "Esp | HighLight", Default = false })

local function createESP(player)
	if not Toggle.Value then
		return
	end

	local highlight = Instance.new("Highlight")
	highlight.Parent = player.Character
	highlight.Adornee = player.Character
	highlight.FillColor = Color3.fromRGB(255, 0, 0)
	highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
	highlight.FillTransparency = 0.5
end

local function removeESP(player)
	local highlight = player.Character and player.Character:FindFirstChildOfClass("Highlight")
	if highlight then
		highlight:Destroy()
	end
end

local function onCharacterAdded(character)
	local player = Players:GetPlayerFromCharacter(character)
	if Toggle.Value then
		createESP(player)
	end
end

local function onPlayerAdded(player)
	player.CharacterAdded:Connect(onCharacterAdded)
	if player.Character then
		onCharacterAdded(player.Character)
	end
end

local function onPlayerRemoving(player)
	removeESP(player)
end

Toggle:OnChanged(function()
	for _, player in pairs(Players:GetPlayers()) do
		if Toggle.Value then
			if player.Character then
				createESP(player)
			end
			player.CharacterAdded:Connect(function(character)
				createESP(player)
			end)
		else
			removeESP(player)
		end
	end
end)

Players.PlayerAdded:Connect(onPlayerAdded)
Players.PlayerRemoving:Connect(onPlayerRemoving)

for _, player in pairs(Players:GetPlayers()) do
	onPlayerAdded(player)
end

if Toggle.Value then
	for _, player in pairs(Players:GetPlayers()) do
		if player.Character then
			createESP(player)
		end
	end
end

--//Health\\--

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

local healthBars = {}

local function createHealthBar(player)
	if player == LocalPlayer then
		return
	end

	local function setupCharacter(char)
		local humanoid = char:WaitForChild("Humanoid")
		local head = char:WaitForChild("Head")

		local billboardGui = Instance.new("BillboardGui")
		billboardGui.Adornee = head
		billboardGui.Size = UDim2.new(0.3, 0, 4, 0)
		billboardGui.StudsOffset = Vector3.new(2, -2, 0)
		billboardGui.AlwaysOnTop = true

		local healthBarBack = Instance.new("Frame", billboardGui)
		healthBarBack.Size = UDim2.new(1, 0, 1, 0)
		healthBarBack.BackgroundColor3 = Color3.new(1, 0, 0)
		healthBarBack.BorderSizePixel = 0

		local healthBar = Instance.new("Frame", healthBarBack)
		healthBar.Size = UDim2.new(1, 0, 1, 0)
		healthBar.AnchorPoint = Vector2.new(0, 1)
		healthBar.Position = UDim2.new(0, 0, 1, 0)
		healthBar.BackgroundColor3 = Color3.new(0, 1, 0)
		healthBar.BorderSizePixel = 0

		billboardGui.Parent = char

		local function updateHealth()
			if humanoid and humanoid.Health > 0 then
				local healthPercent = humanoid.Health / humanoid.MaxHealth
				healthBar.Size = UDim2.new(1, 0, healthPercent, 0)
			else
				billboardGui:Destroy()
			end
		end

		humanoid.HealthChanged:Connect(updateHealth)
		updateHealth()

		table.insert(healthBars, billboardGui)
	end

	if player.Character then
		setupCharacter(player.Character)
	end

	player.CharacterAdded:Connect(function(character)
		setupCharacter(character)
	end)
end

local function destroyAllHealthBars()
	for _, bar in pairs(healthBars) do
		if bar then
			bar:Destroy()
		end
	end
	healthBars = {}
end

local Toggle = Tabs.Esp:AddToggle("HealthBar", { Title = "Health Bar", Default = false })

Toggle:OnChanged(function()
	if Options.HealthBar.Value then
		Players.PlayerAdded:Connect(function(player)
			createHealthBar(player)
		end)

		for _, player in pairs(Players:GetPlayers()) do
			createHealthBar(player)
		end
	else
		destroyAllHealthBars()
	end
end)

Options.HealthBar:SetValue(false)

--//Skeleton\\--

--//Team Check\\--
_G.TeamCheckEnabled = true

_G.TeamCheck = function(player)
	if not _G.TeamCheckEnabled then
		return false
	end

	if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
		local teammateLabel = player.Character.HumanoidRootPart:FindFirstChild("TeammateLabel")
		return teammateLabel ~= nil
	end
	return false
end

--//Esp Corner\\--
local Settings = {
	Box_Color = Color3.fromRGB(255, 0, 0),
	Box_Thickness = 2,
	Team_Color = false,
	Autothickness = true,
}

local Space = game:GetService("Workspace")
local Player = game:GetService("Players").LocalPlayer
local Camera = Space.CurrentCamera

local function NewLine(color, thickness)
	local line = Drawing.new("Line")
	line.Visible = false
	line.From = Vector2.new(0, 0)
	line.To = Vector2.new(0, 0)
	line.Color = color
	line.Thickness = thickness
	line.Transparency = 1
	return line
end

local function Vis(lib, state)
	for i, v in pairs(lib) do
		v.Visible = state
	end
end

local function Colorize(lib, color)
	for i, v in pairs(lib) do
		v.Color = color
	end
end

local DrawBoxesEnabled = false

local Toggle = Tabs.Esp:AddToggle("Corner2d", { Title = "Esp Corner 2D", Default = false })

Toggle:OnChanged(function()
	DrawBoxesEnabled = Toggle.Value
end)

local function Main(plr)
	if _G.TeamCheck(plr) then
		return
	end

	repeat
		wait()
	until plr.Character ~= nil and plr.Character:FindFirstChild("Humanoid") ~= nil
	local R15
	if plr.Character.Humanoid.RigType == Enum.HumanoidRigType.R15 then
		R15 = true
	else
		R15 = false
	end
	local Library = {
		TL1 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
		TL2 = NewLine(Settings.Box_Color, Settings.Box_Thickness),

		TR1 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
		TR2 = NewLine(Settings.Box_Color, Settings.Box_Thickness),

		BL1 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
		BL2 = NewLine(Settings.Box_Color, Settings.Box_Thickness),

		BR1 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
		BR2 = NewLine(Settings.Box_Color, Settings.Box_Thickness),
	}

	local oripart = Instance.new("Part")
	oripart.Parent = Space
	oripart.Transparency = 1
	oripart.CanCollide = false
	oripart.Size = Vector3.new(1, 1, 1)
	oripart.Position = Vector3.new(0, 0, 0)

	local function Updater()
		local c
		c = game:GetService("RunService").RenderStepped:Connect(function()
			if DrawBoxesEnabled then
				if
					plr.Character ~= nil
					and plr.Character:FindFirstChild("Humanoid") ~= nil
					and plr.Character:FindFirstChild("HumanoidRootPart") ~= nil
					and plr.Character.Humanoid.Health > 0
					and plr.Character:FindFirstChild("Head") ~= nil
				then
					local Hum = plr.Character
					local HumPos, vis = Camera:WorldToViewportPoint(Hum.HumanoidRootPart.Position)
					if vis then
						oripart.Size = Vector3.new(
							Hum.HumanoidRootPart.Size.X,
							Hum.HumanoidRootPart.Size.Y * 1.5,
							Hum.HumanoidRootPart.Size.Z
						)
						oripart.CFrame = CFrame.new(Hum.HumanoidRootPart.CFrame.Position, Camera.CFrame.Position)
						local SizeX = oripart.Size.X
						local SizeY = oripart.Size.Y
						local TL = Camera:WorldToViewportPoint((oripart.CFrame * CFrame.new(SizeX, SizeY, 0)).p)
						local TR = Camera:WorldToViewportPoint((oripart.CFrame * CFrame.new(-SizeX, SizeY, 0)).p)
						local BL = Camera:WorldToViewportPoint((oripart.CFrame * CFrame.new(SizeX, -SizeY, 0)).p)
						local BR = Camera:WorldToViewportPoint((oripart.CFrame * CFrame.new(-SizeX, -SizeY, 0)).p)

						-- Team Color settings
						if Settings.Team_Color then
							Colorize(Library, plr.TeamColor.Color)
						end

						local ratio = (Camera.CFrame.p - Hum.HumanoidRootPart.Position).magnitude
						local offset = math.clamp(1 / ratio * 750, 2, 300)

						Library.TL1.From = Vector2.new(TL.X, TL.Y)
						Library.TL1.To = Vector2.new(TL.X + offset, TL.Y)
						Library.TL2.From = Vector2.new(TL.X, TL.Y)
						Library.TL2.To = Vector2.new(TL.X, TL.Y + offset)

						Library.TR1.From = Vector2.new(TR.X, TR.Y)
						Library.TR1.To = Vector2.new(TR.X - offset, TR.Y)
						Library.TR2.From = Vector2.new(TR.X, TR.Y)
						Library.TR2.To = Vector2.new(TR.X, TR.Y + offset)

						Library.BL1.From = Vector2.new(BL.X, BL.Y)
						Library.BL1.To = Vector2.new(BL.X + offset, BL.Y)
						Library.BL2.From = Vector2.new(BL.X, BL.Y)
						Library.BL2.To = Vector2.new(BL.X, BL.Y - offset)

						Library.BR1.From = Vector2.new(BR.X, BR.Y)
						Library.BR1.To = Vector2.new(BR.X - offset, BR.Y)
						Library.BR2.From = Vector2.new(BR.X, BR.Y)
						Library.BR2.To = Vector2.new(BR.X, BR.Y - offset)

						Vis(Library, true)

						if Settings.Autothickness then
							local distance = (Player.Character.HumanoidRootPart.Position - oripart.Position).magnitude
							local value = math.clamp(1 / distance * 100, 1, 4)
							for u, x in pairs(Library) do
								x.Thickness = value
							end
						else
							for u, x in pairs(Library) do
								x.Thickness = Settings.Box_Thickness
							end
						end
					else
						Vis(Library, false)
					end
				else
					Vis(Library, false)
					if game:GetService("Players"):FindFirstChild(plr.Name) == nil then
						for i, v in pairs(Library) do
							v:Remove()
							oripart:Destroy()
						end
						c:Disconnect()
					end
				end
			else
				Vis(Library, false)
			end
		end)
	end
	coroutine.wrap(Updater)()
end

for i, v in pairs(game:GetService("Players"):GetPlayers()) do
	if v.Name ~= Player.Name then
		coroutine.wrap(Main)(v)
	end
end

game:GetService("Players").PlayerAdded:Connect(function(newplr)
	coroutine.wrap(Main)(newplr)
end)

--//Misc\\--

local Toggle = Tabs.Misc:AddToggle("MyToggle", {Title = "Auto-Execute", Default = true})

Toggle:OnChanged(function()
    if Options.MyToggle.Value then
        if queue_on_teleport and sendValidnotif then
            queue_on_teleport("loadstring(game:HttpGet('https://raw.githubusercontent.com/FacilityHUB/Korrupt-Zombie/refs/heads/main/test'))()")
            sendValidnotif("Script will be auto executed on teleport")
        else
            warn("queue_on_teleport or sendValidnotif is not defined.")
        end
    end
end)

--//Settings\\-- Not Delete
SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)

SaveManager:IgnoreThemeSettings()

SaveManager:SetIgnoreIndexes({})

InterfaceManager:SetFolder("Facility Hub")
SaveManager:SetFolder("Facility Hub/Rivals v2.0")

InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)

Window:SelectTab(1)

Fluent:Notify({
	Title = "Fluent",
	Content = "The script has been loaded.",
	Duration = 8,
})

SaveManager:LoadAutoloadConfig()
